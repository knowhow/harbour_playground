<HTML><HEAD></HEAD>
<BODY>

<HTML>
<TITLE>wxHarbour</TITLE>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#400040" ALINK="#FF0000" TOPMARGIN="5" LEFTMARGIN="5">

<P><P><P>

<CENTER>
<FONT SIZE=10>
<H2>wxHarbour</H2>
</FONT>
Multiplatform GUI for [x]Harbour<br>
Powered by wxWidgets<BR>
&copy; 2006-2007 Teo Fonrouge<BR>
WindTelSoft de Mexico
</CENTER>
<P><P><P>
wxHarbour is a set of [x]Harbour language bindings for wxWidgets. Providing a portable multi-platform GUI toolkit for [x]Harbour (a 100% Clipper & XBase compatible compiler).
<P>

wxHarbour tries to replicate the same functions, name calling, parameters and return values to allow using the same documentation found at wxWidgets Home page.

<BR><BR>

<P><P>
<FONT COLOR="" SIZE="3" FACE="Arial, Lucida Sans">
<TT>wxHarbour at: <A HREF="http://sourceforge.net/projects/wxharbour" TARGET="_blank">http://sourceforge.net/projects/wxharbour</A></TT><P>

<TT>Harbour Project at: <A HREF="http://sourceforge.net/projects/harbour-project/" TARGET="_blank">http://sourceforge.net/projects/harbour-project/</A></TT><P>

<TT>xHarbour at: <A HREF="http://sourceforge.net/projects/xharbour/" TARGET="_blank">http://sourceforge.net/projects/xharbour/</A></TT><P>


<TT>wxWidgets at: <A HREF="http://www.wxwidgets.org" TARGET="_blank">http://www.wxwidgets.org</A></TT>

</FONT>
<P><P>


</BODY>

</HTML>

<HTML><HEAD><TITLE>TIndex</TITLE></HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#400040" ALINK="#FF0000" TOPMARGIN="5" LEFTMARGIN="5">
<A NAME="TIndex"></A>
<H2>Currently Ported Classes</H2>
<P>

<A HREF="doc-wxapp.htm">wxApp</A><BR>
<A HREF="doc-wxboxsizer.htm">wxBoxSizer</A><BR>
<A HREF="doc-wxbutton.htm">wxButton</A><BR>
<A HREF="doc-wxdialog.htm">wxDialog</A><BR>
<A HREF="doc-wxevthandler.htm">wxEvtHandler</A><BR>
<A HREF="doc-wxframe.htm">wxFrame</A><BR>
<A HREF="doc-wxgrid.htm">wxGrid</A><BR>
<A HREF="doc-wxgridtablebase.htm">wxGridTableBase</A><BR>
<A HREF="doc-wxmenu.htm">wxMenu</A><BR>
<A HREF="doc-wxmenubar.htm">wxMenuBar</A><BR>
<A HREF="doc-wxmenuitem.htm">wxMenuItem</A><BR>
<A HREF="doc-wxnotebook.htm">wxNotebook</A><BR>
<A HREF="doc-wxpanel.htm">wxPanel</A><BR>
<A HREF="doc-wxsizer.htm">wxSizer</A><BR>
<A HREF="doc-wxstatictext.htm">wxStaticText</A><BR>
<A HREF="doc-wxstatusbar.htm">wxStatusBar</A><BR>
<A HREF="doc-wxtextctrl.htm">wxTextCtrl</A><BR>
<A HREF="doc-wxvalidator.htm">wxValidator</A><BR>
<A HREF="doc-wxwindow.htm">wxWindow</A><BR>

<P>

For further help please see the wxWidgets Documentation.<P>
<P>

</BODY>
</HTML>

<A NAME="wxApp"></A>
<H1>wxApp Class</H1><P>

<!-- List of available messages -->
<A HREF="#wxApp_New">New</A><BR>
<A HREF="#wxApp_OnInit">OnInit</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxApp_New"></A>
<H2>wxApp:New</H2>
<TT>
<B>New</B>()
</TT>
<P>
Constructor
<P><BR><BR>

<HR>
<A NAME="wxApp_OnInit"></A>
<H2>wxApp:OnInit</H2>
<TT>
<B>logical OnInit</B>()
</TT>
<P><BR><BR>

<A NAME="wxBoxSizer"></A>
<H1>wxBoxSizer Class</H1><P>

<!-- List of available messages -->
<A HREF="#wxBoxSizer_New">New</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxBoxSizer_New"></A>
<H2>wxBoxSizer:New</H2>
<TT>
<B>New</B>( [ <I>wxVERTICAL</I> | <I>wxHORIZONTAL</I> ] )
</TT>
<P>
Constructor
<P><BR><BR>

<A NAME="wxButton"></A>
<H1>wxButton Class</H1><P>

<!-- List of available messages -->
<A HREF="#wxButton_New">New</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxButton_New"></A>
<H2>wxButton:New</H2>
<TT>
<B>New</B>()
<P>
</TT>
Default constructor
<P><BR><BR>

<TT>
<B>New</B>( parent, id, label, pos, size, style, validator, name )
<P>
</TT>
Constructor, creating and showing a button
<P><BR><BR>

<A NAME="wxDialog"></A>
<H1>wxDialog Class</H1><P>

<!-- List of available messages -->
<A HREF="#wxDialog_New">New</A><BR>
<A HREF="#wxDialog_Centre">Centre</A><BR>
<A HREF="#wxDialog_CreateButtonSizer">CreateButtonSizer</A><BR>
<A HREF="#wxDialog_CreateStdDialogButtonSizer">CreateStdDialogButtonSizer</A><BR>
<A HREF="#wxDialog_Show">Show</A><BR>
<A HREF="#wxDialog_ShowModal">ShowModal</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxDialog_New"></A>
<H2>wxDialog:New</H2>
<TT>
<B>New</B>()
<P>
</TT>
Default constructor
<P><BR><BR>

<TT>
<B>New</B>( parent, id, title, pos, size, style, name )
<P>
</TT>
Constructor
<P><BR><BR>

<HR>
<A NAME="wxDialog_Centre"></A>
<H2>wxDialog:Centre</H2>
<TT>
<B>NIL Centre</B>( [ <I>wxHORIZONTAL</I> | <I>wxVERTICAL</I> | <I><B>wxBOTH</B></I> ] )
<P>
</TT>
Centres the dialog box on the display
<P><BR><BR>

<HR>
<A NAME="wxDialog_CreateButtonSizer"></A>
<H2>wxDialog:CreateButtonSizer</H2>
<TT>
<B>wxSizer CreateButtonSizer</B>( flags )
<P>
</TT>
Creates a sizer with standard buttons
<P><BR><BR>

<HR>
<A NAME="wxDialog_CreateStdDialogButtonSizer"></A>
<H2>wxDialog:CreateStdDialogButtonSizer</H2>
<TT>
<B>CreateStdDialogButtonSizer</B>( flags )
<P>
</TT>
Creates a wxStdDialogButtonSizer with standard buttons
<P><BR><BR>

<HR>
<A NAME="wxDialog_Show"></A>
<H2>wxDialog:Show</H2>
<TT>
<B>logical Show</B>( show )
<P>
</TT>
Hides or shows the dialog
<P><BR><BR>

<HR>
<A NAME="wxDialog_ShowModal"></A>
<H2>wxDialog:ShowModal</H2>
<TT>
<B>numeric ShowModal</B>()
<P>
</TT>
Shows a modal dialog
<P><BR><BR>


<A NAME="wxEvtHandler"></A>
<H1>wxEvtHandler Class</H1><P>

<!-- List of available messages -->
<A HREF="#wxEvtHandler_New">New</A><BR>
<A HREF="#wxEvtHandler_Connect">Connect</A><BR>
<A HREF="#wxEvtHandler_ProcessEvent">ProcessEvent</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxEvtHandler_New"></A>
<H2>wxEvtHandler:New</H2>
<TT>
<B>New</B>()
<P>
</TT>
Default constructor
<P><BR><BR>

<HR>
<A NAME="wxEvtHandler_Connect"></A>
<H2>wxEvtHandler:Connect</H2>
<TT>
<B>Connect</B>( id, eventType, bAction )
<P>
</TT>
Connect actions to codeblocks
<P><BR><BR>

<HR>
<A NAME="wxEvtHandler_ProcessEvent"></A>
<H2>wxEvtHandler:ProcessEvent</H2>
<TT>
<B>ProcessEvent</B>( wxEvent event )
<P>
</TT>
Processes an event, searching event tables and calling zero or more suitable event handler function(s).
<P><BR><BR>

<A NAME="wxFrame"></A>
<H1>wxFrame Class</H1><P>

<!-- List of available messages -->
<A HREF="#wxFrame_New">New</A><BR>
<A HREF="#wxFrame_Centre">Centre</A><BR>
<A HREF="#wxFrame_SetMenuBar">SetMenuBar</A><BR>
<A HREF="#wxFrame_SetStatusBar">SetStatusBar</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxFrame_New"></A>
<H2>wxFrame:New</H2>
<TT>
<B>New</B>()
<P>
</TT>
Default constructor
<P><BR><BR>

<TT>
<B>New</B>( parent, id, title, pos, size, style, name )
<P>
</TT>
Constructor
<P><BR><BR>

<HR>
<A NAME="wxFrame_Centre"></A>
<H2>wxFrame:Centre</H2>
<TT>
<B>NIL Centre</B>( [ <I>wxHORIZONTAL</I> | <I>wxVERTICAL</I> | <I><B>wxBOTH</B></I> ] )
<P>
</TT>
Centres the frame on the display
<P><BR><BR>

<HR>
<A NAME="wxFrame_SetMenuBar"></A>
<H2>wxFrame:SetMenuBar</H2>
<TT>
<B>NIL SetMenuBar</B>( wxMenuBar menuBar )
<P>
</TT>
Tells the frame to show the given menu bar
<P><BR><BR>

<HR>
<A NAME="wxFrame_SetStatusBar"></A>
<H2>wxFrame:SetStatusBar</H2>
<TT>
<B>NIL SetStatusBar</B>( wxStatusBar statusBar )
<P>
</TT>
Associates a status bar with the frame.
<P><BR><BR>

<A NAME="wxGrid"></A>
<H1>wxGrid Class</H1><P>

wxGrid and its related classes are used for displaying and editing tabular data. They provide a rich set of features for display, editing, and interacting with a variety of data sources. For simple applications, and to help you get started, wxGrid is the only class you need to refer to directly. It will set up default instances of the other classes and manage them for you. For more complex applications you can derive your own classes for custom grid views, grid data tables, cell editors and renderers. The wxGrid classes overview has examples of simple and more complex applications, explains the relationship between the various grid classes and has a summary of the keyboard shortcuts and mouse functions provided by wxGrid.<P>
wxGrid has been greatly expanded and redesigned for wxWidgets 2.2 onwards. If you have been using the old wxGrid class you will probably want to have a look at the wxGrid classes overview to see how things have changed. The new grid classes are reasonably backward-compatible but there are some exceptions. There are also easier ways of doing many things compared to the previous implementation.<P>

<!-- List of available messages -->
<A HREF="#wxGrid_New">New</A><BR>
<A HREF="#wxGrid_CreateGrid">CreateGrid</A><BR>
<A HREF="#wxGrid_Fit">Fit</A><BR>
<A HREF="#wxGrid_GetTable">GetTable</A><BR>
<A HREF="#wxGrid_SetColLabelSize">SetColLabelSize</A><BR>
<A HREF="#wxGrid_SetColLabelValue">SetColLabelValue</A><BR>
<A HREF="#wxGrid_SetDefaultColSize">SetDefaultColSize</A><BR>
<A HREF="#wxGrid_SetDefaultRowSize">SetDefaultRowSize</A><BR>
<A HREF="#wxGrid_SetRowLabelSize">SetRowLabelSize</A><BR>
<A HREF="#wxGrid_SetTable">SetTable</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxGrid_New"></A>
<H2>wxGrid:New</H2>
<TT>
<B>New</B>()
<P>
</TT>
Default constructor
<P><BR><BR>

<TT>
<B>New</B>( parent, id, pos, size, style, name )
<P>
</TT>
Constructor
<P><BR><BR>

<HR>
<A NAME="wxGrid_CreateGrid"></A>
<H2>wxGrid:CreateGrid</H2>
<TT>
<B>logical CreateGrid</B>( numRows, numCols, selmode )
<P>
</TT>
Creates a grid with the specified initial number of rows and columns. Call this directly after the grid constructor. When you use this function wxGrid will create and manage a simple table of string values for you. All of the grid data will be stored in memory.<P>
For applications with more complex data types or relationships, or for dealing with very large datasets, you should derive your own grid table class and pass a table object to the grid with wxGrid::SetTable.
<P><BR><BR>

<HR>
<A NAME="wxGrid_Fit"></A>
<H2>wxGrid:Fit</H2>
<TT>
<B>NIL Fit</B>()
<P>
</TT>
Overridden wxWindow method.
<P><BR><BR>

<HR>
<A NAME="wxGrid_GetTable"></A>
<H2>wxGrid:GetTable</H2>
<TT>
<B>wxGridTableBase GetTable</B>()
<P>
</TT>
Returns a base pointer to the current table object.
<P><BR><BR>

<HR>
<A NAME="wxGrid_SetColLabelSize"></A>
<H2>wxGrid:SetColLabelSize</H2>
<TT>
<B>NIL SetColLabelSize</B>( height )
<P>
</TT>
Sets the height of the column labels.
<P><BR><BR>

<HR>
<A NAME="wxGrid_SetColLabelValue"></A>
<H2>wxGrid:SetColLabelValue</H2>
<TT>
<B>NIL SetColLabelValue</B>( col, value )
<P>
</TT>
Set the value for the given column label. If you are using a derived grid table you must override wxGridTableBase::SetColLabelValue for this to have any effect.
<P><BR><BR>

<HR>
<A NAME="wxGrid_SetDefaultColSize"></A>
<H2>wxGrid:SetDefaultColSize</H2>
<TT>
<B>NIL SetDefaultColSize</B>( width, resizeExistingCols )
<P>
</TT>
Sets the default width for columns in the grid. This will only affect columns subsequently added to the grid unless resizeExistingCols is true.
<P><BR><BR>

<HR>
<A NAME="wxGrid_SetDefaultRowSize"></A>
<H2>wxGrid:SetDefaultRowSize</H2>
<TT>
<B>NIL SetDefaultRowSize</B>( height, resizeExistingCols )
<P>
</TT>
Sets the default height for rows in the grid. This will only affect rows subsequently added to the grid unless resizeExistingRows is true.
<P><BR><BR>

<HR>
<A NAME="wxGrid_SetRowLabelSize"></A>
<H2>wxGrid:SetRowLabelSize</H2>
<TT>
<B>NIL SetRowLabelSize</B>( width )
<P>
</TT>
Sets the width of the row labels.
<P><BR><BR>

<HR>
<A NAME="wxGrid_SetTable"></A>
<H2>wxGrid:SetTable</H2>
<TT>
<B>logical SetTable</B>( table, takeOwnership, selmode )
<P>
</TT>
Passes a pointer to a custom grid table to be used by the grid. This should be called after the grid constructor and before using the grid object. If takeOwnership is set to true then the table will be deleted by the wxGrid destructor.<P>
Use this function instead of <A HREF="#wxGrid_CreateGrid">wxGrid::CreateGrid</A> when your application involves complex or non-string data or data sets that are too large to fit wholly in memory.
<P><BR><BR>

<A NAME="wxGridTableBase"></A>
<H1>wxGridTableBase Class</H1><P>

Grid table classes.<P>

<!-- List of available messages -->
<A HREF="#wxGridTableBase_New">New</A><BR>
<A HREF="#wxGridTableBase_GetNumberCols">GetNumberCols</A><BR>
<A HREF="#wxGridTableBase_GetNumberRows">GetNumberRows</A><BR>
<A HREF="#wxGridTableBase_GetValue">GetValue</A><BR>
<A HREF="#wxGridTableBase_IsEmptyCell">IsEmptyCell</A><BR>
<A HREF="#wxGridTableBase_SetColLabelValue">SetColLabelValue</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxGridTableBase_New"></A>
<H2>wxGridTableBase:New</H2>
<TT>
<B>New</B>()
<P>
</TT>
Default constructor
<P><BR><BR>

<HR>
<A NAME="wxGridTableBase_GetNumberCols"></A>
<H2>wxGridTableBase:GetNumberCols</H2>
<TT>
<B>numeric GetNumberCols</B>()
<P>
</TT>

<P><BR><BR>

<HR>
<A NAME="wxGridTableBase_GetNumberRows"></A>
<H2>wxGridTableBase:GetNumberRows</H2>
<TT>
<B>numeric GetNumberRows</B>()
<P>
</TT>
You must override these functions in a derived table class.
<P><BR><BR>

<HR>
<A NAME="wxGridTableBase_GetValue"></A>
<H2>wxGridTableBase:GetValue</H2>
<TT>
<B>string GetValue</B>( row, col )
<P>
</TT>

<P><BR><BR>

<HR>
<A NAME="wxGridTableBase_IsEmptyCell"></A>
<H2>wxGridTableBase:IsEmptyCell</H2>
<TT>
<B>logical IsEmptyCell</B>( row, col )
<P>
</TT>

<P><BR><BR>

<HR>
<A NAME="wxGridTableBase_SetColLabelValue"></A>
<H2>wxGridTableBase:SetColLabelValue</H2>
<TT>
<B>NIL SetColLabelValue</B>( col, label )
<P>
</TT>

<P><BR><BR>

<A NAME="wxMenu"></A>
<H1>wxMenu Class</H1><P>

Grid table classes.<P>

<!-- List of available messages -->
<A HREF="#wxMenu_New">New</A><BR>
<A HREF="#wxMenu_Append">Append</A><BR>
<A HREF="#wxMenu_AppendSeparator">AppendSeparator</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxMenu_New"></A>
<H2>wxMenu:New</H2>
<TT>
<B>New</B>()
<P>
</TT>
Default constructor
<P><BR><BR>

<HR>
<A NAME="wxMenu_Append"></A>
<H2>wxMenu:Append</H2>
<TT>
<B>wxMenuItem Append</B>( id, item, helpString, kind )
<P>
</TT>
Adds a string item to the end of the menu.
<P><BR><BR>

<TT>
<B>wxMenuItem Append</B>( id, item, subMenu, helpString )
<P>
</TT>
Adds a pull-right submenu to the end of the menu. Append the submenu to the parent menu after you have added your menu items, or accelerators may not be registered properly.
<P><BR><BR>

<TT>
<B>wxMenuItem Append</B>( menuItem )
<P>
</TT>
Adds a menu item object. This is the most generic variant of Append() method because it may be used for both items (including separators) and submenus and because you can also specify various extra properties of a menu item this way, such as bitmaps and fonts.
<P><BR><BR>

<HR>
<A NAME="wxMenu_AppendSeparator"></A>
<H2>wxMenu:AppendSeparator</H2>
<TT>
<B>wxMenuItem AppendSeparator</B>()
<P>
</TT>
Adds a separator to the end of the menu.
<P><BR><BR>

<A NAME="wxMenuBar"></A>
<H1>wxMenuBar Class</H1><P>

A menu bar is a series of menus accessible from the top of a frame.<P>

<!-- List of available messages -->
<A HREF="#wxMenuBar_New">New</A><BR>
<A HREF="#wxMenuBar_Append">Append</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxMenuBar_New"></A>
<H2>wxMenuBar:New</H2>
<TT>
<B>New</B>( style )
<P>
</TT>
Default constructor
<P><BR><BR>

<TT>
/* TODO: Implement this */
<B>New</B>( n, menus, titles, style )
<P>
</TT>
Construct a menu bar from arrays of menus and titles.
<P><BR><BR>

<HR>
<A NAME="wxMenuBar_Append"></A>
<H2>wxMenuBar:Append</H2>
<TT>
<B>Append</B>( menu AS wxMenu, title ) AS LOGICAL
<P>
</TT>
Adds the item to the end of the menu bar.
<P><BR><BR>

<A NAME="wxMenuItem"></A>
<H1>wxMenuItem Class</H1><P>

A menu item represents an item in a menu. Note that you usually don't have to deal with it directly as wxMenu methods usually construct an object of this class for you.<P>
Also please note that the methods related to fonts and bitmaps are currently only implemented for Windows and GTK+.<P>

<!-- List of available messages -->
<A HREF="#wxMenuItem_New">New</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxMenuItem_New"></A>
<H2>wxMenuItem:New</H2>
<TT>
<B>New</B>( parentMenu, id, text, helpString, kind, subMenu )
<P>
</TT>
Constructs a wxMenuItem object.<P>
Menu items can be standard, or "stock menu items'', or custom. For the standard menu items (such as commands to open a file, exit the program and so on, see stock items for the full list) it is enough to specify just the stock ID and leave text and helpString empty. In fact, leaving at least text empty for the stock menu items is strongly recommended as they will have appearance and keyboard interface (including standard accelerators) familiar to the user.<P>
For the custom (non-stock) menu items, text must be specified and while helpString may be left empty, it's recommended to pass the item description (which is automatically shown by the library in the status bar when the menu item is selected) in this parameter.
Finally note that you can e.g. use a stock menu label without using its stock help string:
<P><BR><BR>


<A NAME="wxNotebook"></A>
<H1>wxNotebook Class</H1><P>

This class represents a notebook control, which manages multiple windows with associated tabs.<P>
To use the class, create a wxNotebook object and call AddPage or InsertPage, passing a window to be used as the page. Do not explicitly delete the window for a page that is currently managed by wxNotebook.<P>

<!-- List of available messages -->
<A HREF="#wxNotebook_New">New</A><BR>
<A HREF="#wxNotebook_AddPage">AddPage</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxNotebook_New"></A>
<H2>wxNotebook:New</H2>
<TT>
<B>New</B>()
<P>
</TT>
Default constructor.
<P><BR><BR>

<TT>
<B>New</B>( parent, id, pos, size, style, name )
<P>
</TT>
Constructs a wxNotebook object.
<P><BR><BR>

<HR>
<A NAME="wxNotebook_AddPage"></A>
<H2>wxNotebook:AddPage</H2>
<TT>
<B>AddPage</B>( page, text, select, imageld )
<P>
</TT>
Adds a new page.<P>
The call to this function may generate the page changing events.
<P><BR><BR>

<A NAME="wxPanel"></A>
<H1>wxPanel Class</H1><P>

A panel is a window on which controls are placed. It is usually placed within a frame. It contains minimal extra functionality over and above its parent class wxWindow; its main purpose is to be similar in appearance and functionality to a dialog, but with the flexibility of having any window as a parent.<P>
Note: if not all characters are being intercepted by your OnKeyDown or OnChar handler, it may be because you are using the wxTAB_TRAVERSAL style, which grabs some keypresses for use by child controls.<P>

<!-- List of available messages -->
<A HREF="#wxPanel_New">New</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxPanel_New"></A>
<H2>wxPanel:New</H2>
<TT>
<B>New</B>()
<P>
</TT>
Default constructor.
<P><BR><BR>

<TT>
<B>New</B>( parent, id, pos, size, style, name )
<P>
</TT>
Constructs a wxPanel object.
<P><BR><BR>


<A NAME="wxSizer"></A>
<H1>wxSizer Class</H1><P>

wxSizer is the abstract base class used for laying out subwindows in a window. You cannot use wxSizer directly; instead, you will have to use one of the sizer classes derived from it. Currently there are wxBoxSizer, wxStaticBoxSizer, wxGridSizer wxFlexGridSizer and wxGridBagSizer.<P>
The layout algorithm used by sizers in wxWidgets is closely related to layout in other GUI toolkits, such as Java's AWT, the GTK toolkit or the Qt toolkit. It is based upon the idea of the individual subwindows reporting their minimal required size and their ability to get stretched if the size of the parent window has changed. This will most often mean that the programmer does not set the original size of a dialog in the beginning, rather the dialog will be assigned a sizer and this sizer will be queried about the recommended size. The sizer in turn will query its children, which can be normal windows, empty space or other sizers, so that a hierarchy of sizers can be constructed. Note that wxSizer does not derive from wxWindow and thus does not interfere with tab ordering and requires very little resources compared to a real window on screen.<P>
What makes sizers so well fitted for use in wxWidgets is the fact that every control reports its own minimal size and the algorithm can handle differences in font sizes or different window (dialog item) sizes on different platforms without problems. If e.g. the standard font as well as the overall design of Motif widgets requires more space than on Windows, the initial dialog size will automatically be bigger on Motif than on Windows.<P>
Sizers may also be used to control the layout of custom drawn items on the window. The Add, Insert, and Prepend functions return a pointer to the newly added wxSizerItem. Just add empty space of the desired size and attributes, and then use the wxSizerItem::GetRect method to determine where the drawing operations should take place.<P>
Please notice that sizers, like child windows, are owned by the library and will be deleted by it which implies that they must be allocated on the heap. However if you create a sizer and do not add it to another sizer or window, the library wouldn't be able to delete such an orphan sizer and in this, and only this, case it should be deleted explicitly..<P>

<!-- List of available messages -->
<A HREF="#wxSizer_New">New</A><BR>
<A HREF="#wxSizer_Add">Add</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxSizer_New"></A>
<H2>wxSizer:New</H2>
<TT>
<B>New</B>()
<P>
</TT>
Default constructor.
<P><BR><BR>

<HR>
<A NAME="wxSizer_Add"></A>
<H2>wxSizer:Add</H2>
<TT>
<B>Add</B>( window, flags )
<P>
</TT>
<P><BR><BR>

<TT>
<B>Add</B>( window, proportion, flag, border, userData )
<P>
</TT>
<P><BR><BR>

<TT>
<B>Add</B>( sizer, flags )
<P>
</TT>
<P><BR><BR>

<TT>
<B>Add</B>( sizer, proportion, flag, border, userData )
<P>
</TT>
<P><BR><BR>

<TT>
<B>Add</B>( width, height, proportion, flag, border, userData )
<P>
</TT>
<P><BR><BR>
Appends a child to the sizer. wxSizer itself is an abstract class, but the parameters are equivalent in the derived classes that you will instantiate to use it so they are described here:<P>
window<BR>
The window to be added to the sizer. Its initial size (either set explicitly by the user or calculated internally when using wxDefaultSize) is interpreted as the minimal and in many cases also the initial size.<P>
sizer<BR>
The (child-)sizer to be added to the sizer. This allows placing a child sizer in a sizer and thus to create hierarchies of sizers (typically a vertical box as the top sizer and several horizontal boxes on the level beneath).<P>
width and height<BR>
The dimension of a spacer to be added to the sizer. Adding spacers to sizers gives more flexibility in the design of dialogs; imagine for example a horizontal box with two buttons at the bottom of a dialog: you might want to insert a space between the two buttons and make that space stretchable using the proportion flag and the result will be that the left button will be aligned with the left side of the dialog and the right button with the right side - the space in between will shrink and grow with the dialog.
proportion<P>
Although the meaning of this parameter is undefined in wxSizer, it is used in wxBoxSizer to indicate if a child of a sizer can change its size in the main orientation of the wxBoxSizer - where 0 stands for not changeable and a value of more than zero is interpreted relative to the value of other children of the same wxBoxSizer. For example, you might have a horizontal wxBoxSizer with three children, two of which are supposed to change their size with the sizer. Then the two stretchable windows would get a value of 1 each to make them grow and shrink equally with the sizer's horizontal dimension.<P>
flag<BR>
This parameter can be used to set a number of flags which can be combined using the binary OR operator |. Two main behaviours are defined using these flags. One is the border around a window: the border parameter determines the border width whereas the flags given here determine which side(s) of the item that the border will be added. The other flags determine how the sizer item behaves when the space allotted to the sizer changes, and is somewhat dependent on the specific kind of sizer used.<P>
wxTOP
wxBOTTOM
wxLEFT
wxRIGHT
wxALL <BR>
These flags are used to specify which side(s) of the sizer item the border width will apply to. <P>
wxEXPAND <BR>
The item will be expanded to fill the space assigned to the item. <P>
wxSHAPED <BR>
The item will be expanded as much as possible while also maintaining its aspect ratio <P>
wxFIXED_MINSIZE <BR>
Normally wxSizers will use GetAdjustedBestSize to determine what the minimal size of window items should be, and will use that size to calculate the layout. This allows layouts to adjust when an item changes and its best size becomes different. If you would rather have a window item stay the size it started with then use wxFIXED_MINSIZE. <P>
wxALIGN_CENTER wxALIGN_CENTRE
wxALIGN_LEFT
wxALIGN_RIGHT
wxALIGN_TOP
wxALIGN_BOTTOM
wxALIGN_CENTER_VERTICAL wxALIGN_CENTRE_VERTICAL
wxALIGN_CENTER_HORIZONTAL wxALIGN_CENTRE_HORIZONTAL <BR>
The wxALIGN flags allow you to specify the alignment of the item within the space allotted to it by the sizer, adjusted for the border if any. <P>
border<BR>
Determines the border width, if the flag parameter is set to include any border flag.<P>
userData<BR>
Allows an extra object to be attached to the sizer item, for use in derived classes when sizing information is more complex than the proportion and flag will allow for.<P>
flags<BR>
A wxSizerFlags object that enables you to specify most of the above parameters more conveniently.<P>


<A NAME="wxStaticText"></A>
<H1>wxStaticText Class</H1><P>

A static text control displays one or more lines of read-only text.<P>

<!-- List of available messages -->
<A HREF="#wxStaticText_New">New</A><BR>
<A HREF="#wxStaticText_Wrap">Wrap</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxStaticText_New"></A>
<H2>wxStaticText:New</H2>
<TT>
<B>New</B>()
<P>
</TT>
Default constructor.
<P><BR><BR>

<TT>
<B>New</B>( parent, id, label, pos, size, style, name )
<P>
</TT>
Constructor, creating and showing a text control.
<P><BR><BR>

<HR>
<A NAME="wxStaticText_Wrap"></A>
<H2>wxStaticText:Wrap</H2>
<TT>
<B>NIL Wrap</B>( width )
<P>
</TT>
This functions wraps the controls label so that each of its lines becomes at most width pixels wide if possible (the lines are broken at words boundaries so it might not be the case if words are too long). If width is negative, no wrapping is done.<P>
This function is new since wxWidgets version 2.6.2
<P><BR><BR>

<A NAME="wxStatusBar"></A>
<H1>wxStatusBar Class</H1><P>

A status bar is a narrow window that can be placed along the bottom of a frame to give small amounts of status information. It can contain one or more fields, one or more of which can be variable length according to the size of the window.<P>

<!-- List of available messages -->
<A HREF="#wxStatusBar_New">New</A><BR>
<A HREF="#wxStatusBar_SetFieldsCount">SetFieldsCount</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxStatusBar_New"></A>
<H2>wxStatusBar:New</H2>
<TT>
<B>New</B>()
<P>
</TT>
Default constructor.
<P><BR><BR>

<TT>
<B>New</B>( parent, id, style, name )
<P>
</TT>
Constructor, creating the window.
<P><BR><BR>

<HR>
<A NAME="wxStatusBar_SetFieldsCount"></A>
<H2>wxStatusBar:SetFieldsCount</H2>
<TT>
<B>NIL SetFieldsCount</B>( number, widths )
<P>
</TT>
Sets the number of fields, and optionally the field widths.
<P><BR><BR>

<A NAME="wxTextCtrl"></A>
<H1>wxTextCtrl Class</H1><P>

A text control allows text to be displayed and edited. It may be single line or multi-line.<P>

<!-- List of available messages -->
<A HREF="#wxTextCtrl_New">New</A><BR>
<A HREF="#wxTextCtrl_GetValue">GetValue</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxTextCtrl_New"></A>
<H2>wxTextCtrl:New</H2>
<TT>
<B>New</B>()
<P>
</TT>
Default constructor.
<P><BR><BR>

<TT>
<B>New</B>( parent, id, value, pos, size, style, validator, name )
<P>
</TT>
Constructor, creating and showing a text control.
<P><BR><BR>

<HR>
<A NAME="wxTextCtrl_GetValue"></A>
<H2>wxTextCtrl:GetValue</H2>
<TT>
<B>string GetValue</B>()
<P>
</TT>
Gets the contents of the control. Notice that for a multiline text control, the lines will be separated by (Unix-style) n characters, even under Windows where they are separated by a rn sequence in the native control.
<P><BR><BR>

<A NAME="wxValidator"></A>
<H1>wxValidator Class</H1><P>

wxValidator is the base class for a family of validator classes that mediate between a class of control, and application data.<P>
A validator has three major roles:<P>
1. 
to transfer data from a C++ variable or own storage to and from a control; <P>
2. 
to validate data in a control, and show an appropriate error message; <P>
3. 
to filter events (such as keystrokes), thereby changing the behaviour of the associated control. <P>
Validators can be plugged into controls dynamically.<P>
To specify a default, 'null' validator, use the symbol wxDefaultValidator.<P>

<!-- List of available messages -->
<A HREF="#wxValidator_New">New</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxValidator_New"></A>
<H2>wxValidator:New</H2>
<TT>
<B>New</B>()
<P>
</TT>
Default constructor.
<P><BR><BR>

<A NAME="wxWindow"></A>
<H1>wxWindow Class</H1><P>

wxWindow is the base class for all windows and represents any visible object on screen. All controls, top level windows and so on are windows. Sizers and device contexts are not, however, as they don't appear on screen themselves.<P>
Please note that all children of the window will be deleted automatically by the destructor before the window itself is deleted which means that you don't have to worry about deleting them manually. Please see the window deletion overview for more information.<P>
Also note that in this, and many others, wxWidgets classes some GetXXX() methods may be overloaded (as, for example, GetSize or GetClientSize). In this case, the overloads are non-virtual because having multiple virtual functions with the same name results in a virtual function name hiding at the derived class level (in English, this means that the derived class has to override all overloaded variants if it overrides any of them). To allow overriding them in the derived class, wxWidgets uses a unique protected virtual DoGetXXX() method and all GetXXX() ones are forwarded to it, so overriding the former changes the behaviour of the latter.<P>

<!-- List of available messages -->
<A HREF="#wxWindow_Close">Close</A><BR>
<A HREF="#wxWindow_GetId">GetId</A><BR>
<A HREF="#wxWindow_Hide">Hide</A><BR>
<A HREF="#wxWindow_IsShown">IsShown</A><BR>
<A HREF="#wxWindow_SetSizer">SetSizer</A><BR>
<A HREF="#wxWindow_Show">Show</A><BR>

<!-- Description of messages -->
<HR>
<A NAME="wxWindow_Close"></A>
<H2>wxWindow:Close</H2>
<TT>
<B>Close</B>( force ) AS LOGICAL
<P>
</TT>
This function simply generates a wxCloseEvent whose handler usually tries to close the window. It doesn't close the window itself, however.
<P><BR><BR>

<HR>
<A NAME="wxWindow_GetId"></A>
<H2>wxWindow:GetId</H2>
<TT>
<B>GetId</B>() AS NUMERIC
<P>
</TT>
Returns the identifier of the window.<P>
Remarks<P>
Each window has an integer identifier. If the application has not provided one (or the default wxID_ANY) an unique identifier with a negative value will be generated.
<P><BR><BR>

<HR>
<A NAME="wxWindow_Hide"></A>
<H2>wxWindow:Hide</H2>
<TT>
<B>Hide</B>() AS LOGICAL
<P>
</TT>
Equivalent to calling Show(false).
<P><BR><BR>

<HR>
<A NAME="wxWindow_IsShown"></A>
<H2>wxWindow:IsShown</H2>
<TT>
<B>IsShown</B>() AS LOGICAL
<P>
</TT>
Returns true if the window is shown, false if it has been hidden.
<P><BR><BR>

<HR>
<A NAME="wxWindow_SetSizer"></A>
<H2>wxWindow:SetSizer</H2>
<TT>
<B>SetSizer</B>( sizer, deleteOld )
<P>
</TT>
Sets the window to have the given layout sizer. The window will then own the object, and will take care of its deletion. If an existing layout constraints object is already owned by the window, it will be deleted if the deleteOld parameter is true.<P>
Note that this function will also call SetAutoLayout implicitly with true parameter if the sizer is non-NULL and false otherwise.
<P><BR><BR>

<HR>
<A NAME="wxWindow_Show"></A>
<H2>wxWindow:Show</H2>
<TT>
<B>Show</B>( show ) AS LOGICAL
<P>
</TT>
Shows or hides the window. You may need to call Raise for a top level window if you want to bring it to top, although this is not needed if Show() is called immediately after the frame creation.
<P><BR><BR>

</BODY>
</HTML>
